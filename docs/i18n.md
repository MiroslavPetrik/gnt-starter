# i18n

- âœ… Works for client & server components and server actions.
- âœ… Support for active pathname checks via `useLngPathname()`.
- âœ… Extraction of translation keys via `i18next-parser`.
- âœ… Integrated with `zod` both for key translation & extraction including custom translation keys.

## Configuration

1. Add your language code into [options array](./src/i18n/options.ts#L5).
2. Import your `zod` translations and add into [resources map](./src/i18n/options.ts#L12)
3. Run `npm run i18n` which will create empty folders & json maps for your locales from added in step 1.
4. Fill the translations & commit changes.
5. ðŸŽ‰ Your app is translated!

## Usage

### Server Components

```tsx
/**
 * Use the custom RSC Params type which gives you the global `[lng]` param.
 */
import { Params } from "@/types";
/**
 * Import the SSR translation helper from a local `i18n` folder.
 * NOTE: the SSR helper is awaited!
 */
import { translate } from "@/i18n";

export default async function Page({ params }: Params) {
  const { lng } = await params;
  // Specify the feature name as your namespace.
  // Use the "global" namespace for reusable components like Button.
  const { t } = await translate("feature", lng);

  return <h1>{t("title")}</h1>;
}
```

You can also use this 'hook' in the server actions. See the [auth actions](./src/app/actions/auth.ts#L27) as an example.

### Client Components

In client components, we use the hook `useTranslation()` from a library.

```tsx
import { useTranslation } from "react-i18next";

export function CreateUserForm() {
  const { t } = useTranslation("onboarding");
}
```

On the client side, the import of translation files is handled in the `RootLayout` by the [`<Language />` component](./src/i18n/client.tsx#L33).

### Client Navigation Components

Since the `[lng]` param is present in every `pathname`, we extend the `usePathame()` from Next.js,
with a functionality to strip the prefix away, so you can check for active path easily:

```tsx
"use client";
/**
 * Import useLngPathname instead of the usePathname
 */
import { useLngPathname } from "@/i18n/use-lng-pathname";
/**
 * Get the type for prop which will be passed from the server component params.
 */
import { type LanguageParam } from "@/i18n";

export function NavbarLinks({ lng }: LanguageParam) {
  // pathname no longer contains the lng prefix!
  const pathname = useLngPathname(lng);
  const { t } = useTranslation("global");

  // we can check if the path is active without worrying about the language:
  return (
    <nav>
      <NavbarLink href="/" active={pathname === "/"}>
        {t("link.home")}
      </NavbarLink>
      <NavbarLink href="/dashboard" active={pathname.startsWith("/dashboard")}>
        {t("link.dashboard")}
      </NavbarLink>
    </nav>
  );
}
```

See [full code of the `<NavbarLinks />`](<./src/app/[lng]/(user)/_components/navbar-links.tsx>).

### Custom Zod Errors

When you use `.refine()` API of `zod`, the custom error must be defined in `params` as follows:

```tsx
/**
 * The local "t" function is necessary for the i18next-parser to extract the translation key properly.
 */
import { t } from "@/i18n";

const customError = z.string().refine((val) => val, {
  // The "zodError" namespace here is mandatory & typechecked
  // The actual key, will be passed down to the zod-i18n-map which will do the translation.
  params: { i18n: t("zodError:passwordsMustMatch") },
});
```

See the translation of the [`passwordsMustMatch` refinement](./src/app/actions/auth.ts#L85) .
